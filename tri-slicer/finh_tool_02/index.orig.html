<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cfec5c298d3b4d96c37cc083081b8ef0667d96e5cefe765116d882f53919b54eaae403439c4caca17a82f65e322f3b5694853bb6823d5c5666580c50b38769f101493d804498d216e38b5825b9905051f1c2b339d9914e437051c135045450aca859a28013ae3110967c6a1437ceba5650db9f0fddab7ab12ce16bf659b54cd9c48a8fb474179faaf3c7733d2c4f0104cbaf490438a38d167622779c6c455ee9e720662d79ed4428a53c7a0a44154429b43285561d6dcaa5079ba92c4bfe3040d330b07454e1da0eefd53c209e8dc0d039f0dc7facfed0d6d859b8c885df103794d32e477b2863deeb36653225830e46823c727785a86e8bad21e13dfb91c53c1d6f3acbf9b5cce3c717a461a738ee6602a8c9a3fff8d1d41ba3388bbd8a16001a504c634b3616dae8aa1a7f2a5262f49044c33c6cff9492f5564d3dc1f8160634bd81cfe7244c94fcc5bd4f5a0087e790a8f421b6c69c879f52ce44e727361bad081f9086372d22791863b619e4b1762bb4ee7ec611b96f72e7730d9c8635d68a408cce73d77c2675527de2c04ed7075209bb28d2ac7069c4e87875f0ec993f6a13957cde1e5fe1074c0d2d538974eaa980b5c0fc419adc08c207f3e6ca5e9cbe4ff07e27b27527f7a354b015d87be84288f42cdb36b850835b81f33a555e3e75db911da43ce7c0e30108b076253ea0e1f996b19196c68b8b0232983eb96d4592d84aa8f5b2e5f598dcef683073b05ff81b062ab3d23b5e648b8abe7ccae93ae0625e704ae2a6617610055e2152b7413ffba1cc53e123950e098baf08f70878f271e63278696594c4a528c3475f7aa0dda91bf9aa12d950741789f8a6745c48418b78967478b0d0382d42940caf1e73266827092fcfd81b79ecca680c49ba52126f5f74f2f76ce8710384f6523fa8470629613d17b2005f2257da931262a97e08ff6d10372ed8d2d3a8d45d7e20a2ee44b9aa6cda12eb6364189800028e816fbb128243461a55d33a72049b787ccb5b96b22058c5c49b482c9893d370719452def0e6e1b0c2539180f2c21cc493eb10e971be2080381fa9da03a6b08567cc709e722770ccc2e85521d9776f71a21cf7dd2d35645a50bdf742b249179153e5d01e6baa7033e4a0ceb05e02b7daa503f4351e1c1c7bc2bd5c4610b9f0c1184fe8e6575db49a892d7559c6f6daaa41b8fa36cc67e9954e58da4bec5a60acbda267ba1a6e7679b6f511aea7bdb48def58b0f6b0c80160707dd8f38c350c62ef2ffdc1b72f3c347037f816bd1996ff0bb6085b3ae74c5a69f2c0133475191b06eeaaeb1504ddbc7456b3c7516d98bddda978cec7f0b1453e2cd1d3050365628d8f7bbb30ff6c3cfa9a08e1591d1223015df6da9fe3a299723c3464971175eada988c31275a1c586026ea4e2510cdcd99f20376acc8037fcabc9557bfb2e7e3bcc7a811b983120a741329d6c37c2116f4e22b23b6f76b65de3ea7ba7c734b46161d1acfebae9d115fb97cd0dfaea6705d54298c3ce60d42fa53b19f7b39810b83bd9fced5f4d5faa3b955e05c8d389d1acffc0b381258f6641ef169455468974f418a93ae1d156bb0a9ab98a5f69e8071a803aa675a5db54706eb228bbcc5ec54c82620d5110c2387cedf2128427d3a59b7b769eb025d6043799794b039c3d11c1b8dae7f15028f1fed21910558328e3539ffe85432f39ce25e8d392474a16dedb52f4f60386a2ed2b63b4fc2528fd38d433fa01cfd33282b510372d3d19a8d17021c0d6c6fdd81cec8e307917316cc5497733b9a554a4fde36189dec6b73a53b8c02418a5777bb861bd1c4e0aee67d3ac3e75336fa28168ddd9bf22e34ed90713633abafbca45defbf0de43227386f6984860e697d9f26eb59a41ab7ac1783c16bd22c7b01f41450ea8a895d9ef86d2c3abdea476bbb6cc5d51b933137464e511693e9ad3d90f7c6419004877d5f70319365009f87a068e655b2145da716a8470180a0f9f0481f782cf60309c171f5355c6954f6c42320a7cab82182ddf78bc6dcc38cb3b384310d444dcdfa1299501abac0f9bf2de3fd83ec6ab7663669ce7c16c55099aae530ea68d6fac1ccce840832f470a3c967270a2d33958eb9dce17b0627597ed8b282bb55344d4162cc9439e926d5d80f9a125aad3b5abfa1cfba202a596baae462e50501602876b74d633e09f942983286801a1e86dcef6e7f9232ea03167dfc0491ad4d58411db60033465f2b729b95c3407ef7e6d781ca433793634f07377f477325f8c0d08c9e33791a74829fb00474539d254c9d025bb7f4bc3d89e7ed8f5963a8ea5563f38338222327329791f93abd0c1b16f4f335978a19c09df7baa0b33f0988e5996a11bf229fe0a2714afb4f7e5be2bcc7b968c93dc978709de4b3f2600aae9d9d31020c024e14a0b57a626101a47d7b927031254b417aedff0520a2ec3fabb35ff10bb92c4c37db1c6df78de0b5438bae24055d6e263b8f9a90eca8740f35337e6f24f74705b2b0ab82afa941d06dad8494d97d8160a6a022988880da3b235a70fb34777443f87c63125b004839fe4a4f2e8fb1346038e8cb4058950f356bb7ab0db1e2e602ac0b6dd35af011ecba2e1d7a6ebd94a80c1b7a3f0739fe9dc509f03054ae35ceccea6dc6ed5515e05af2c22611275467baacb4dc116e7644548e4515e33c6334923baa27a19609b01137bf1f1dd85fe8001b732b57735ad1cd396383251c889595fe121b58ca61b22a5dd40e7391b4cf407a708ccb15a8e1d5da83e6661f10bb08c827b4cd6835a4993d3bd7b8e00227beb84d762ea521e0a99ec5c00f11f6167982f586acd603e10e1b9997c7cebd9f8174cb131e7e691d786bd5258367f411cb1199b6afa94e1a6672e98cd741f09a40602e917599d6a0896e3b11ab7934c99601e772cedc061e34493a9c2f1f4d2de71294a6714e2e78b996e7e8d74252ee086052ad8ca930e1a14496e818c05125197e3f0e6be34654fda08c5e0d800deda507b484d2efe4c559a7427455b41b1fb1c4a35cd2bba62354f9dad9965aae0ecc9a7193defc65616fd7b1dab5d243e80fd32c288f62b72660a7ac573e63ee24bb7acc615450f578c2f8be68f70d552d5bff2bb93bf74fb49cd20a6a2e9e6cd8fd1dcd0a345fd754d19b2201a1f11c55ee802aa9cb8ae8f6e0798d42574717e3762d1d527cba78ba1dac260a83df6036bb9a7930700704535dfbb3ebcf476de67d2887bc71404d604732a297ed8bb6526cd5f2cefed659fedf9a3d6c8154e2b1a9bc30dfd1a2eed0bbcd5d4d679a7513ca9cd3cb2588e70f8d42864279de963774e5a8a40c7b6eb52fb0482fa704320e411b28227618266c3969f21f2df145b8e02e73d36068ea258f66267fa4a67a9a9dbea75cc34a5ca574a4c0e45d96a07a14ff85e5338c31183c90beb1ac0cf018af4a879177080db6cd40efadc27b831a47b351add3980b8443e06ae15066fbfc889b223aec3b559442fbfb7ffb2f256520425c0b61132d398a8cf98513fbf395f3bb0fdbb49cd6edb90227d7ed7609bf680a90beab4a249827c40aca5c01fc5d8494fa8ad81f7ecb14565d1066132569bd864fa70a02b5f279e7e6c1c1757d3e15b0386478d97519cf72a17f4279db8ad831d66b2a9007b87d46f7ee43554ef7e419a431155680e2f95b56ca0f95215f583c83ba438c11e461ee0776dd06fcf00078e776cda5e708c1cef3eea2aae0fa8a21c469e7b8dc937e8f5d23e8c7f2cae683e06aea357a3a8c5d8906793310b562dccf6a975a53260422d31c2a54db4353d6e174a447493cfb9e227abbe60adfdd2d085b61799060ec711f703c01a0e00e6fbdb4df355947f1c36457cc6ba9e92d74c52917e88203f897d7ebdffa08c6ec1f04824370c1b22e9b5a52a6ca1afc5aecb7e4ccaa2339dfe78956b2776ffd88ac6666131b431bc05bdea7b6348e28b62091cdb5f43aede1746b09199324057d0fc6e7e8cc19829a2ec2e09b6fd0f57d3ed0a772dd1419e4df41fcfc0df297a567cd1fcdd3a099dbf364269b7233f221002f1e45941d2374fbe73e9f813af9d748dadfb9cc38d655fe72aa3986120b69a87e3685c6225b81ddd4671f9c1d9bffc89e2dcf3635ebdc0068d06c7e320496b5475dc3f057b9301defc5883835723388b9a2ccf0fdeb239a27a49c63ef2d21f654a4b171490cc142f3b6372e5da4db6b94dbb8bedc9e1ab259f8a7dbd6e9238da5dd4659fe454879723ccb0e23437520c6c307d2d0da0c3ba499ca741c5eb9ea07d4f5fefadb5d8da0d6ef2a63d4a3e4d283456c8d1d6bc7009c0c12838c974aada4d6943550db690c0e30edc65f1918db853c78d078a2846b6f799c4a805e0ba267f1a94722b8177a852bc4c0d33a2e01e4dabfc18f4345b316f2f5423983fae253b264a77108b1ebb141c09680cd782f4b04db62c33f7fa73ace162f1b0fa6ef5dc8765e40c001d1d9a82a08ba9c25c431538a7759f6312c5da847ab0e2dce29b42ed1a7e70b2d724dbaf12620057e900876d80acdbb6cdf09d6391728184bc31a9bba134730b8fbf02a5b5d4f5543a56ec11ca556f245730d3bea7c0bff4089f3ac5cc4accac2929d7a808c9fa2ae414b694692756b3ab1e66fdbec41bd6eff55cc5e133699f58205b782e99987a873cf4141dd609451e2ff4e5692ff8e2593da25e4538b5ad8b5f179669510c533f4d5bf1ede23fc93b320811cba8befaf2733e6cd2a002131b8877043850959e558cd19b2ac609cbbc5a06673a43ea5c131cc6106172ed3c774bf8b4ca8a194ffeaf229e0bd3235a7d80df14997df9968e1d77c67da713d714b7afb57f6097fd18f56f6681e5d40a4f6b70a3c2cea01dbf86dc48a36bd87de5b7ff94bd8493a7eb9177b60ce70fa08beca07dc2a2f0a9208cf189939519434bbce71d5cf8b456c60b04bee2dfc72dc6f2fb8884af22473e4afcbb6bf6bd8bb6867ba5e39c7bfa2db26de672df7d9a625d4957d6faf3dc36705d49b34a8726502d7acfe9ce1de6531c150aebd52baaf2d157d31f3956aa307d89d8aebf3639dd93ed651680ebfbf6b3a78c652f2d08ef201e2039dda2e5dd6934989c56ddc5705c0a74d7ddb26977f819208a593a039056e5632109dd4791bc71a8523471fa612e549836d6daaf2c92fba2ee49084d9c16c432eff1de5a9f1aa770f88030570509eb35784f6eba99ababe56148025fff23a97778444431af9bae78de16b84bbc781990750ed65d28cc35b1c80cf4fef30b0ebe2fcaa15c89b32f6423d590c6bb2f3ab38ac47d99b588e9bf48694a8da2ce9e862593bc5487c18bc5c3edcf3f6894f6f620fc265bd9a1fd61dbfa3515464af45f26adc36893521b217b04ebffc2ed4bd96aabbcdd74b2a249e72d9edb4d954119daac19bab33e758a840136bb62ff463542ea9f64ab9f6576a220b488a4ba0ac6cd5233913c67b44dc15fc2a1618ad85a0988e173baef4eca153ef036a2186fc040997f871141826072de51db88deb34ca765845c167ecd7c35b981d0c979cca2a570a6d9ed77e26fcb28b34529b7c6f8341a7de8f2c24748fb03546923ad24c125236261dfb13eca512fdff70dcdf876122a33f5d1e8101e6439644ca9c479a54218c2e897daf14933d4a725de5dc186686337dbb28b2cb8272037b6ee89bbdc87b111cd4bb6e578134db6ccf6c4622d46b55716d37c46eb89e976db3252ce6c67f92d8f9a0e7b9f62efea7631ef2be0d3ac3314fd21ea614a37778701002878f6b108013e781ca2f2152e5da67171dc8dc7ed264897a8305478fd6ba6d25585fdcf36f10d251496bc963efcb8e2418a7c070ffa49b0044845ce1db6ad3d99ba63016d97c6c93899b94132ca89fce226988c75b6d4e03ceba1fea8a9254ffd16dfead0a6f87b8db9b3bd2fd556315d8b14a7dbbb9e814794b0c5d4d1ea89b5230ccb00390500f081cc5a5193649c8036abdddc244379d680e028f78360f800a03ac21e9ba96588d4b3d68a6a4625975071d26ebb83bf9ec6a8fa6ad069df1d762d8fb137b653fb2ffbd2fcfbd345603d9b07a9589186eddc4d1c40a93798a3a2ef1fc6500c8927d76267c93a790cec686217515ea151efdf661a099a01b9a34456aee81a6bb7cd629972716c3e9df28bbaf0783db7f50bab820e7db03235602fe7895c194409a289823fc94339d12caeab9831a4aec55b58449187ccdcc6ccaea2271a6cf729dcef5360f3d2bf7811710ad02e1b93790975a6cf52ed422675b27080a73c902d3d31ac788630d804e63e95c03cd65563e9758cd9ae5c9c7ac1fd33b512ff43d2e300fb2a2826da2eaccb85814cfbac0c8080823a974a322302b853c4e925282f9165ade5133805ddfc10084e94d64c8ea0ff3ac862e4c5cda7c14c5855065b4acee311049ddb3c87549f3b9f023bee15b02a3702bc4e66aea797721ae46f796a01ce464b7c112c071d238156436208e84d43a202721d6d21f71979e454b796b5e9a1397874e6e3c793d4ca1ffe154e205f4554bf6beae9deb79647666a4b43b17c570a8cffdf758fcbe737953296d835d824cf7d8db1d77b97b604fcb069083d46a6380a517a0ffd9242097cc4bf1e1d48eec2ccbd2df83f5b7f2dc5b4ab9a883117eddfbec5af3ce3d22a0f4008d35c86769492b38f44ae54ed059c3e15b8a78d2663c53a110481bf2a27775e334e3420d7ed2131c8b0041ecdcfc47a086475cd72195f8775528634568cc8ca0d9556db70cc4de5ca06bf81b6148d16ee7fe2eb072a68594244c20976672a31b5d908b93de9c2e30276c28edcbe58b3ad455803dd66e10a419fc9bd7589a5033c7233e435071dd51e0af728ce66f2ba40bce0dd8e7d3bb417f0e1290a56e6f9184bff5b67fd882ae6d665e302bc8f4b5fd8033abb875be92bc2d1d91f5a91c03ea1555877a576cd73de7214b13425ba7eba134c3115fd0d25a332f2bc85ec957186e07965a7fbf7987ede6dad902824d502f983cc58941f20f71b308677b0057a7cdd8160ec81ded9eb22b9ec27e24f647e3e9db47366e78cf92b48bbbb57aca6a743082e38a75ed9fcbffb3353af0f8c1c7e24ece9520bf46970249694ab9514cf4aafb7294bddc36500c6f466e201febf676baf802796715fff9e093b3f9eb95bfc77b47d6eddb3b0d9ff40ca4633ac5e6820fa3da4f91cc7f2b991a85ec4201e698a35d0dc3602c4434028b63e3dbb7a2c6cfdae66f4791f812c8d51e5c709f874e36cb0bde0ce6725ea66269197bef7d0df0ccdef081a504db669d7497ce3053107f97f1295cf2c20232650e0e54da46e0de33dcf4c5390e8cba1304136419120d726899e938f8bd29d383bf9efa92274a30ef5a7592e278d708d142a3a27e77f8b43a667e3a59645a3cec5478ea7440e4cf6184035345f3a8b28de5aaaa84fb176ed34a173e0791ec28c2df9fe03f2d7d1144543d1950a05ce1458d61dab49cd752c29f7a9693f8b6dd958235d833917d06cd32688812bee8f015fd648b47569b7eccc102f32a4d1c629488da2ae3e8ea77a24e741b54529239d2d9f0a1e5737c06dd372859788d48a85011550d36ed16bf6822402e3018174358d3a7d1b13dbd9b9bcb701a9f623d17ec24fdf5e828952d3b54079d7efb49a9e745ea9d3c330eb6cd82475c3179b7c541ca52ac9e3780484163e4f542bb4565e76957da3f98b7319d11d174f392e127152d7f255f08e54e4d7def7c19d6c8279650342af55591bacd79194c994d0dc00d3eb1dff802be05556576418d310b740354c041f0f61b429d51be28298c6733b2cdaa5c1d9d3808199b5818d5fcc6b9f65b3ab1144b8a75757baaf5ba2a8d643212404b853dbe26e863037a3c0a7461c78eac26bd7c89dc75737291e792b531359ced3ea0dec488cc29bbfaa839eeeea4d744eeb385f70609faba7e2926efc8c850b11a3ece9db5987e5b266315185ccda3349d92f8c088067429ca9f51c62d71af542074ce05b23613789689f9dbf94a2dde703bd31e606093f16942d8ecfdd1e3884755e787a945d7aabfc62a5d2c26d32d8930caf269bc861b01a9ecb6bb019af0e86bb3f6ae4d8c0af4be6b46798908258f146ff251df8ca0d1186d32fca658c6a5e66b0eb57dbd5123e9e363cd25a719ee1973f66feb6b60503775ec0dd83dd5b94a62865c9bb89dd9121dc69ed213796e09d9887aa6d700ac0a6cfbb9047ab548aafc3b561491d039d3b7e4137396321ef923b4e465fbcbb100eb4baffb8fd2dc0ff337b6be66fd2298e568b64f9a1cffabb9c3f91c6ee704cad7afb5b1450f2f8e48467784260e43aa8f2909ee9c9e695d8248ef09ce982c600ebaf465846a6f90d035435c9a605884e4699b10a262ee9923b7d229712b521d8325032599bbc66124fb82147b3d88ab6d7f5973b8d280eb215a05d1b161daf84dc56aa5ec6c0b1994ef86c92d92a30924b34d87ca1abb27ba135998f6a7e16b060ace4674c26720493ab599656503f4ca7c87f81b152de5b1dbad2e21a5bc2e1845e3e420bd058f8bd52b9fce122f63c8aca828478c46e55a4fb576092cae7edce70aff4240135646fc60bb3fb5b6e61ef845e09ec8210d71a93b0d30c1fb49d254c7ac24babc8916ad7fc43dfadf8891efd143854f6aa7c44095a199a9369431df602249fb68f3aa3e18bae68c59d24f6025fc01f238545ee4225884d1843ad8a39231408d24dc3923acef3a0a3d58f574022a9df85f6e3c7da2e04d219ce956def79d5bb8d0b05b8b77dcf3293c1264a0183b6bd82d051d004255a4372ab482a1a2560e4ca237c0af5bd0d58d7f5564830baae761576069d711ef97a44d53d8ac682d29e4f353682de109c7780164acfb469dd0b38e51c6e4a75c85cc90267a6b7745567fe62158e7b153179b81d7e483eb903e8d5f96442174014189b3e17eb0e8a2a3ef4fd74c4abdb507b48eadbf910d22984880c5b4f74b7e364618f4eeffba4858d3418342967937932cda8b582de954d11514c93d04b23e94a866aeb2d153c771031a1de42d7c6fcf00e6635df795d34c1cc444f2298d698b42325dc2d61a2e29444b6f284338b80f79c77b26b5cb6be0f2bc8a00079faeee2a9c33827537973d9b49881d3e46b24ab4a98a8f1117607f31862b40f72fce3627c7b29cf8bcdacf46b5f1ca4b46393af9042846e4dc6707d7ccc844ae1e3aeba8f63faa344e286a6ef7d9cd9e5d4f0a458619b0842414560eaf63bc56cd1dda31854d478d9b32e9b0ddcf06b3d5f8beaa31d3cdb2b8f16b18801d4b6e6df6113521deed6bf0f99f95cd39de8d2b03c8f8430f82df27f3d72ead9c5220ccbb990650c43d641d6abed38ef47b57d7de0a84fda3e81cbb46526c959e716a5bc41508ff9fdd7ea646ed8bf2931d4100833c119e697d47ab2d7951f385fa21f9d5bb75a9c751fb043dabc8d1683bff0be06e121b3b2dd14c04aef6a4403c53d187739c3ec43c87bea2ba73fbc0052ff6c50416e2f705a6e256f6c53da4e1c8bee481875549ca7b8eba04008bb5fb137544d29244ea3db8662e336d8d1c68f9056d643bed4409ca9102d19bb173f981a378cff92a54ce1237418447f4de4f98ac5a2a1f44685a4a1f5ea8b64103b65959c01904ca073ae032b2f885a724719a1d332b28e1bc629698d512923f00483cff9820cfa82013cd7e05481366fc20d45706f594be61db8453f845cedf197713215da393afcb49ccbd9e9310f153a756d4ec67d1dafe0b03ef337465e5596b8177277b73b3c63ca1c3f92bdc0c06a693af7ba4727e675effa39f1ee1f706e0f22c7d4bf6271a4c6db978e8efdf9b4f7c3b8384277564eb21afd69d2caa5ce46e37d166c95f63b1ce8c4b14d65042aae8ed3c96a8f6f086dbf18d3f9fa4e2d9f2440eb3e2a5452c6b587c7c150a4f393b1e8669fb1a9666b13f989f9c68e71205a430bf51108e663aafe1893a52809ca9e61cf3314b9ebddfd4db0543f26a0287498f718313d58456b61b2e7576253b5b48b4f6ec28d5fbc078031c6a802f2b8465799f9b15401fe3029cad5bc61bc55a8045a73562abf02e7a26c8d83de27a6289f60a49a55c30d6546abac27e7c56301ba9d85092b0e4d5c6d38f715bb287d8dccaec2cf172adcac51eeae0a6b267ad784805e917273a56003ae99f2da9f612a5bbb260c78232385938368ef9abb6229ab46fc6d4c15b190a747c222d993559b88e41d263d4972ba500cd8643e6ba1c65059b838711b12186eaad55595727a739273342e97f53261ecb416da664d05a086b0206d3677318c0a7aadfb31c1ff265905883dd24fe59b2540743227d3b305e1a5288a2b20c9c2ca04556a338c43d82d1b5dc9148524d63b9f35c39dde1baf20ee1d62f0a651ec7b54ae3d3604fbc0f041742a4f9435049d6bceef45df45f1ec3c4d60f8c6e94133ccc15f89e88014f48a1f2b751bdc7f7ec18b839a696792238bb255c526a9df5fcf65a4464588e8c71312154c30e432436bb0009cedc0b5d0da469b150f04cc200c7e161b8edf4f92da731263897cc345f8cdfd9aa677812c325958a19fa0e82907058bc70017bcbc6ef3da9f51c7fba38775dc9d8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c3cca022d1ca15d402ebd2eb81363484"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
